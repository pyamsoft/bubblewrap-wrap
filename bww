#!/bin/sh
#
# The GPLv2 License
#
#   Copyright (C) 2019  Peter Kenji Yamanaka
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# bubblewrap-wrap

##
# Split a long option with embedded equals (=) and return the argument
# $1 option name
# $2 argument
split_equal_get_arg()
{
  full_arg="$1"
  printf -- '%s' "${full_arg}" | tr '=' ' ' | awk '{ print $2 }'
  unset full_arg
}

##
# Block a target from being accessed in the jail
#
# If the target is a directory, it will be mounted with --tmpfs
# $1 target
block_in_jail()
{
  target="$1"

  if [ -z "${target}" ]; then
    printf -- 'W: Unable to block_in_jail, no argument\n'
    return 1
  fi

  if [ ! -e "${target}" ]; then
    printf -- 'Unable to block target: %s, does not exist.\n' "${target}"
    return 1
  fi

  if [ -d "${target}" ]; then
    printf -- 'Blocking target dir %s via tmpfs\n' "${target}"
    __bw_opts="${__bw_opts}
  --tmpfs ${target}"
  else
    printf -- 'Unable to block non-directory target: %s\n' "${target}"
  fi
}

##
# Bind if exists
# $1 - path
__bind_if_exists()
{
  if [ -e "$1" ]; then
    # If its a symlink, bind the real file too
    if [ -L "$1" ]; then
      real_path="$(realpath "$1")"
      if [ -e "${real_path}" ]; then
        printf -- 'Bind in jail %s\n' "${real_path}"
        __bw_opts="${__bw_opts}
  --bind ${real_path} ${real_path}"
      else
        printf -- 'W: Unable to bind symlink %s, real path %s does not exist\n' \
          "$1" "${real_path}"
      fi
    fi

    # Always bind requested
    printf -- 'Bind in jail %s\n' "$1"
    __bw_opts="${__bw_opts}
  --bind $1 $1"
  else
    printf -- 'W: Unable to bind %s, path does not exist\n' "$1"
  fi
}

##
# Bind if exists
# $@ - paths
bind_if_exists()
{
  for path in "$@"; do
    __bind_if_exists "${path}"
  done
}

##
# RO-Bind if exists
# $1 - path
__robind_if_exists()
{
  if [ -e "$1" ]; then
    # If its a symlink, ro-bind the real file too
    if [ -L "$1" ]; then
      real_path="$(realpath "$1")"
      if [ -e "${real_path}" ]; then
        printf -- 'RO-bind in jail %s\n' "${real_path}"
        __bw_opts="${__bw_opts}
  --ro-bind ${real_path} ${real_path}"
      else
        printf -- 'W: Unable to ro-bind symlink %s, real path %s does not exist\n' \
          "$1" "${real_path}"
      fi
    fi

    # Always ro-bind requested
    printf -- 'RO-bind in jail %s\n' "$1"
    __bw_opts="${__bw_opts}
  --ro-bind $1 $1"
  else
    printf -- 'W: Unable to ro-bind %s, path does not exist\n' "$1"
  fi
}

##
# RO-Bind if exists
# $@ - paths
robind_if_exists()
{
  for path in "$@"; do
    __robind_if_exists "${path}"
  done
}

##
# DEV-Bind if exists
# $1 - path
__devbind_if_exists()
{
  if [ -e "$1" ]; then
    # If its a symlink, dev-bind the real file too
    if [ -L "$1" ]; then
      real_path="$(realpath "$1")"
      if [ -e "${real_path}" ]; then
        printf -- 'DEV-bind in jail %s\n' "${real_path}"
        __bw_opts="${__bw_opts}
  --dev-bind ${real_path} ${real_path}"
      else
        printf -- 'W: Unable to dev-bind symlink %s, real path %s does not exist\n' \
          "$1" "${real_path}"
      fi
    fi

    # Always dev-bind requested
    printf -- 'DEV-bind in jail %s\n' "$1"
    __bw_opts="${__bw_opts}
  --dev-bind $1 $1"
  else
    printf -- 'W: Unable to dev-bind %s, path does not exist\n' "$1"
  fi
}

##
# DEV-Bind if exists
# $@ -- paths
devbind_if_exists()
{
  for path in "$@"; do
    __devbind_if_exists "${path}"
  done
}

##
# Make jail directory
# $1 - jail dir
# $2 - command
make_jail()
{
  # Make the jail directory
  mkdir -p "$1" || {
    printf -- 'Unable to prepare jail root directory for: %s\n' "$2"
    return 1
  }

  # Make jail home
  mkdir -p "$1/home" || {
    printf -- 'Unable to prepare jail home directory for: %s\n' "$2"
    return 1
  }

  # Make jail var/tmp
  mkdir -p "$1/var/tmp" || {
    printf -- 'Unable to prepare jail var/tmp directory for: %s\n' "$2"
    return 1
  }

  return 0
}

##
# Checks to see if we should apply an option
# $1 the option to ignore
has_option()
{
  for option in ${__ignore_opts}; do
    # Option is in ignore list, do not apply
    if [ "${option}" = "$1" ]; then
      return 1
    fi
  done

  # Option was not found in ignore list, apply
  return 0
}

usage()
{
  printf -- '%s\n\n' "$(cat << EOF
usage: bww [options] <program> [program-arguments]

  --help                    Display this help

  --bind-if-exists <path>   Bind a path outside of jail to the same path
                            in jail if the directory exists
  --robind-if-exists <path> Read only bind a path outside of jail to
                            the same path in jail if the directory exists
  --forcename <name>        Force the jail to be named using the given name
                            instead of adopting the program's name
  --shell                   Launch bash inside of the jail instead of running
                            the program itself

  --nodev                   Do not sandbox /dev, use real /dev
  --notmp                   Do not sandbox /tmp
  --noaudio                 Do not allow pulseaudio in jail
  --nouser                  No user namespace sandboxing
  --noipc                   No ipc namespace sandboxing
  --nopid                   No pid namespace sandboxing
  --nouts                   No uts namespace sandboxing
  --nocgroup                No cgroup namespace sandboxing
  --nosession               Do not create a new session (for CLI applications)
  --nodrop                  Do not drop capabilities after launch
  --nox11                   Do not bind X11 socket
  --nodbus                  Do not bind dbus daemon socket
  --nogl                    Do not allow 3D graphics in jail
  --nothemes                Do not adopt existing desktop themes for GTK and QT

  --v4l                     Allow access to v4l devices
  --systemd                 Allow access to systemd from jail
  --dconf                   Allow access to dconf from jail
  --keyring                 Allow access to gnome-keyring from jail
  --gpg                     Allow access to gnupg from jail
  --p11                     Allow access to polkit from jail
  --gvfs                    Allow access to GVFS from jail

EOF
)" || return 1
  bwrap --help || return 1
  return 0
}

main()
{
  if ! command -v bwrap > /dev/null 2>&1; then
    printf -- 'bwrap is not installed.\n'
    return 1
  fi

  # Loop and consume arguments until we can't anymore

  launch_shell=0
  force_jail_name=""
  pre_opts=""
  binds=""
  robinds=""
  run_opts=""
  while :; do
    case "$1" in
      --help)
        usage || return 1
        return 0
        ;;
      --nodev)
        __ignore_opts="${__ignore_opts} dev"
        run_opts="${run_opts}
--nodev"
        printf -- 'INFO: Not sandboxing /dev\n'
        shift
        ;;
      --notmp)
        __ignore_opts="${__ignore_opts} tmp"
        run_opts="${run_opts}
--notmp"
        printf -- 'INFO: Not sandboxing /tmp\n'
        shift
        ;;
      --noaudio)
        __ignore_opts="${__ignore_opts} audio"
        run_opts="${run_opts}
--noaudio"
        printf -- 'INFO: PulseAudio not allowed in jail\n'
        shift
        ;;
      --nouser)
        __ignore_opts="${__ignore_opts} user"
        run_opts="${run_opts}
--nouser"
        printf -- 'INFO: Not using user namespace\n'
        shift
        ;;
      --noipc)
        __ignore_opts="${__ignore_opts} ipc"
        run_opts="${run_opts}
--noipc"
        printf -- 'INFO: Not using IPC namespace\n'
        shift
        ;;
      --nopid)
        __ignore_opts="${__ignore_opts} pid"
        run_opts="${run_opts}
--nopid"
        printf -- 'INFO: Not using PID namespace\n'
        shift
        ;;
      --nouts)
        __ignore_opts="${__ignore_opts} uts"
        run_opts="${run_opts}
--nouts"
        printf -- 'INFO: Not using UTS namespace\n'
        shift
        ;;
      --nocgroup)
        __ignore_opts="${__ignore_opts} cgroup"
        run_opts="${run_opts}
--nocgroup"
        printf -- 'INFO: Not using CGROUP namespace\n'
        shift
        ;;
      --nosession)
        __ignore_opts="${__ignore_opts} session"
        run_opts="${run_opts}
--nosession"
        printf -- 'INFO: Not running in new session\n'
        shift
        ;;
      --nodrop)
        __ignore_opts="${__ignore_opts} drop"
        run_opts="${run_opts}
--nodrop"
        printf -- 'INFO: Not dropping capabilities\n'
        shift
        ;;
      --nox11)
        __ignore_opts="${__ignore_opts} x11"
        run_opts="${run_opts}
--nox11"
        printf -- 'INFO: X11 not allowed in jail\n'
        shift
        ;;
      --nodbus)
        __ignore_opts="${__ignore_opts} dbus"
        run_opts="${run_opts}
--nodbus"
        printf -- 'INFO: DBUS not allowed in jail\n'
        shift
        ;;
      --nogl)
        __ignore_opts="${__ignore_opts} gl"
        run_opts="${run_opts}
--nogl"
        printf -- 'INFO: GL|3d graphics not allowed in jail\n'
        shift
        ;;
      --nothemes)
        __ignore_opts="${__ignore_opts} themes"
        run_opts="${run_opts}
--nothemes"
        printf -- 'INFO: GTK/QT themes not allowed in jail\n'
        shift
        ;;
      --keyring)
        __ignore_opts="${__ignore_opts} nokeyring"
        run_opts="${run_opts}
--keyring"
        printf -- 'INFO: gnome-keyring allowed in jail\n'
        shift
        ;;
      --dconf)
        __ignore_opts="${__ignore_opts} nodconf"
        run_opts="${run_opts}
--dconf"
        printf -- 'INFO: dconf allowed in jail\n'
        shift
        ;;
      --gpg)
        __ignore_opts="${__ignore_opts} nogpg"
        run_opts="${run_opts}
--gpg"
        printf -- 'INFO: gnupg allowed in jail\n'
        shift
        ;;
      --p11)
        __ignore_opts="${__ignore_opts} nop11"
        run_opts="${run_opts}
--p11"
        printf -- 'INFO: p11-kit allowed in jail\n'
        shift
        ;;
      --gvfs)
        __ignore_opts="${__ignore_opts} nogvfs"
        run_opts="${run_opts}
--gvfs"
        printf -- 'INFO: GVFS allowed in jail\n'
        shift
        ;;
      --systemd)
        __ignore_opts="${__ignore_opts} nosystemd"
        run_opts="${run_opts}
--systemd"
        printf -- 'INFO: systemd allowed in jail\n'
        shift
        ;;
      --v4l)
        __ignore_opts="${__ignore_opts} nov4l"
        run_opts="${run_opts}
--v4l"
        printf -- 'INFO: v4l allowed in jail\n'
        shift
        ;;
      --bind-if-exists)
        # Eat argument
        shift
        # Add to list
        binds="$1 ${binds}"
        run_opts="${run_opts}
--bind-if-exists $1"
        shift
        ;;
      --bind-if-exists=*)
        split_arg="$(split_equal_get_arg "$1")"
        binds="${split_arg} ${binds}"
        run_opts="${run_opts}
--bind-if-exists=${split_arg}"
        unset split_arg
        shift
        ;;
      --robind-if-exists)
        # Eat argument
        shift
        # Add to list
        robinds="$1 ${robinds}"
        run_opts="${run_opts}
--robind-if-exists $1"
        shift
        ;;
      --robind-if-exists=*)
        split_arg="$(split_equal_get_arg "$1")"
        robinds="${split_arg} ${robinds}"
        run_opts="${run_opts}
--robind-if-exists=${split_arg}"
        unset split_arg
        shift
        ;;
      --forcename)
        # --forcename should have 1 argument, shift 1 more time
        shift
        force_jail_name="$1"
        run_opts="${run_opts}
--forcename $1"
        shift
        ;;
      --forcename=*)
        split_arg="$(split_equal_get_arg "$1")"
        force_jail_name="${split_arg}"
        run_opts="${run_opts}
--forcename=${split_arg}"
        unset split_arg
        shift
        ;;
      --tmpfs)
        # should have 1 arguments, shift 1 more times
        pre_opts="${pre_opts} $1"
        run_opts="${run_opts}
$1"
        shift
        pre_opts="${pre_opts} $1"
        run_opts="${run_opts} $1"
        shift
        ;;
      --tmpfs=*)
        split_arg="$(split_equal_get_arg "$1")"
        pre_opts="${pre_opts} --tmpfs ${split_arg}"
        run_opts="${run_opts}
--tmpfs=${split_arg}"
        unset split_arg
        shift
        ;;
      --setenv|--bind|--ro-bind)
        # should have 2 arguments, shift 2 more times
        pre_opts="${pre_opts} $1"
        run_opts="${run_opts}
$1"
        shift
        pre_opts="${pre_opts} $1"
        run_opts="${run_opts} $1"
        shift
        pre_opts="${pre_opts} $1"
        run_opts="${run_opts} $1"
        shift
        ;;
      --shell)
        launch_shell=1
        run_opts="${run_opts}
--shell"
        shift
        ;;
      --*)
        pre_opts="${pre_opts} $1"
        run_opts="${run_opts}
$1"
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  # Shorten the command to just the basename
  if [ "$(basename "$0")" = "bww" ]; then
    if [ -z "$1" ]; then
      printf -- 'Must specify a command\n'
      usage || return 1
      return 1
    fi
    bw_command="$1"
    short_command="$(basename "$1")"
  else
    short_command="$(basename "$0")"
    bw_command="${short_command}"
  fi
  # eat argument
  shift

  if ! command -v "${bw_command}" > /dev/null 2>&1; then
    printf -- 'Invalid command: %s\n' "${bw_command}"
    usage || return 1
    return 1
  fi

  jail_name=""
  if [ -n "${force_jail_name}" ]; then
    jail_name="${force_jail_name}"
  else
    jail_name="${short_command}"
  fi

  jail="${HOME}/.bww/jails/${jail_name}"
  make_jail "${jail}" "${bw_command}" || return 1

  # These are always set, there is no good reason for you to unset these
  __bw_opts="${__bw_opts}
  --proc /proc"
  __bw_opts="${__bw_opts}
  --die-with-parent"

  # If the user wants access to devices, we can't make read only
  if has_option "dev"; then
    __bw_opts="${__bw_opts}
  --ro-bind / /"
  else
    __bw_opts="${__bw_opts}
  --dev-bind / /"
  fi

  # If we fake dev, mount fake dev stuff
  if has_option "dev"; then
    __bw_opts="${__bw_opts}
  --dev /dev"
    # Started bugging out
    # __bw_opts="${__bw_opts}
  # --mqueue /dev/mqueue"
  fi

  # Restrict other homes
  block_in_jail "/home"
  __bw_opts="${__bw_opts}
  --bind ${jail}/home ${HOME}"

  # Blacklist first
  block_in_jail "/boot"
  block_in_jail "/usr/lib/modules-load.d"
  block_in_jail "/usr/lib/sysctl.d"
  block_in_jail "/usr/lib/systemd"
  block_in_jail "/etc/modules-load.d"
  block_in_jail "/etc/modprobe.d"
  block_in_jail "/etc/sysctl.d"
  block_in_jail "/etc/systemd"

  # Not on every system (Debian for example)
  block_in_jail "/usr/lib/modules"
  block_in_jail "/usr/lib/modprobe.d"

  # Blacklist any mass storage directories by default
  block_in_jail "/storage"

  # Block /tmp access unless ignored
  if has_option "tmp"; then
    block_in_jail "/tmp"
  fi

  # Block the /run directory
  block_in_jail "/run"
  block_in_jail "/run/lock"

  # Bind the real user directory
  bind_if_exists "/run/user/$(id -u)"

  # Bind var
  robind_if_exists "/var"
  __bw_opts="${__bw_opts}
  --bind ${jail}/var/tmp /var/tmp"

  # For PulseAudio
  if has_option "audio"; then
    robind_if_exists "${HOME}/.config/pulse"
    devbind_if_exists "/dev/snd"
  else
    block_in_jail "/run/user/$(id -u)/pulse"
    block_in_jail "/dev/snd"
  fi

  if has_option "user"; then
    __bw_opts="${__bw_opts}
  --unshare-user-try"
  fi

  if has_option "ipc"; then
    __bw_opts="${__bw_opts}
  --unshare-ipc"
  fi

  if has_option "pid"; then
    __bw_opts="${__bw_opts}
  --unshare-pid"
  fi

  if has_option "uts"; then
    __bw_opts="${__bw_opts}
  --unshare-uts"
  fi

  if has_option "cgroup"; then
    __bw_opts="${__bw_opts}
  --unshare-cgroup-try"
  fi

  if has_option "session" && [ "${launch_shell}" -eq 0 ]; then
    __bw_opts="${__bw_opts}
  --new-session"
  fi

  if has_option "drop"; then
    __bw_opts="${__bw_opts}
  --cap-drop ALL"
  fi

  # Bind X11 socket
  if has_option "x11"; then
    if has_option "tmp"; then
      robind_if_exists "/tmp/.X11-unix/X0"
    fi
    robind_if_exists "/etc/X11"

    # Authorize clients to connect to Xserver
    robind_if_exists "${HOME}/.Xauthority"
  fi

  # If we have a dbus entry in the user run dir
  if has_option "dbus"; then
    bind_if_exists "/run/dbus"
    bind_if_exists "${HOME}/.dbus"
  else
    block_in_jail "/run/user/$(id -u)/bus"
    block_in_jail "/run/user/$(id -u)/dbus-1"
  fi

  # Any program which relies on dconf
  if ! has_option "nodconf"; then
    robind_if_exists "${HOME}/.config/dconf"
  else
    block_in_jail "/run/user/$(id -u)/dconf"
  fi

  # Any program which relies on gnome-keyring
  if ! has_option "nokeyring"; then
    robind_if_exists "${HOME}/.local/share/keyrings"
  else
    block_in_jail "/run/user/$(id -u)/keyring"
  fi

  # Any program which relies on gnupg
  if ! has_option "nogpg"; then
    robind_if_exists "${HOME}/.gnupg"
  else
    block_in_jail "/run/user/$(id -u)/gnupg"
  fi

  # Any program which relies on polkit and p11-kit
  if ! has_option "nop11"; then
    # No user polkit files that I know of
    true
  else
    block_in_jail "/run/user/$(id -u)/p11-kit"
    block_in_jail "/etc/pkcs11"
    block_in_jail "/etc/polkit-1"
    block_in_jail "/usr/share/polkit-1"
    block_in_jail "/usr/lib/polkit-1"
  fi

  # Any program which relies on GVFS
  if ! has_option "nogvfs"; then
    robind_if_exists "${HOME}/.gvfs"
    robind_if_exists "${HOME}/.local/share/gvfs-metadata"
  else
    block_in_jail "/run/user/$(id -u)/gvfs"
  fi

  # Any program which relies on systemd
  if ! has_option "nosystemd"; then
    # Bind systemd socket
    bind_if_exists "/run/systemd"
  fi

  # Any program which relies on v4l
  if ! has_option "nov4l"; then
    # Bind v4l devices if we are not using real dev
    if has_option "dev"; then
      devbind_if_exists "/dev/v4l"
      devbind_if_exists /dev/video*
    fi
  fi

  # Any theme related dirs
  if has_option "themes"; then
    robind_if_exists "/etc/gtk-2.0"
    robind_if_exists "/etc/gtk-3.0"
    robind_if_exists "${HOME}/.config/user-dirs.dirs"
    robind_if_exists "${HOME}/.config/user-dirs.locale"
    robind_if_exists "${HOME}/.config/Trolltech.conf"
    robind_if_exists "${HOME}/.config/qt5ct"
    robind_if_exists "${HOME}/.config/kdeglobals"
    robind_if_exists "${HOME}/.gtkrc"
    robind_if_exists "${HOME}/.gtkrc-2.0"
    robind_if_exists "${HOME}/.config/gtk-2.0"
    robind_if_exists "${HOME}/.config/gtk-3.0"
    robind_if_exists "${HOME}/.fonts"
    robind_if_exists "${HOME}/.fonts.conf"
    robind_if_exists "${HOME}/.config/fontconfig"
  else
    block_in_jail "/etc/gtk-2.0"
    block_in_jail "/etc/gtk-3.0"
  fi

  # Bind the mesa caches so they are not re-created for each jail
  if has_option "gl"; then
    if has_option "dev"; then
      devbind_if_exists "/dev/dri"
    fi

    mkdir -p "${HOME}/.cache/mesa_shader_cache" || {
      printf -- 'Failed prepping mesa_shader_cache cache directory\n'
      return 1
    }
    bind_if_exists "${HOME}/.cache/mesa_shader_cache"

    # Bind drirc if it exists as read-only
    robind_if_exists "${HOME}/.drirc"
  fi

  # Preset read only binds
  robind_if_exists "/usr/bin"
  robind_if_exists "/usr/sbin"
  robind_if_exists "/usr/lib"
  robind_if_exists "/usr/lib32"
  robind_if_exists "/usr/lib64"
  robind_if_exists "/usr/share"
  robind_if_exists "/usr/include"
  robind_if_exists "/usr"
  robind_if_exists "/etc/fonts"
  robind_if_exists "/etc/group"
  robind_if_exists "/etc/hostname"
  robind_if_exists "/etc/hosts"
  robind_if_exists "/etc/mime.types"
  robind_if_exists "/etc/nsswitch.conf"
  robind_if_exists "/etc/passwd"
  robind_if_exists "/etc/resolv.conf"
  robind_if_exists "/etc/xdg"
  robind_if_exists "/etc"

  # Extra binds
  for binding in ${binds}; do
    bind_if_exists "${binding}"
  done
  for robinding in ${robinds}; do
    robind_if_exists "${robinding}"
  done
  unset binds
  unset robinds

  if [ -n "${run_opts}" ]; then
    printf -- '\nbww with options: %s\n\n' "${run_opts}"
  fi

  if [ "${launch_shell}" -eq 0 ]; then
    # Launch the program
    printf -- 'Run brwap: %s\n%s \n%s %s\n' "${__bw_opts}" "${pre_opts}" \
      "${bw_command}" "$*"

    # shellcheck disable=SC2086
    exec bwrap ${__bw_opts} ${pre_opts} "${bw_command}" "$@" || return 1
  else
    # Launch bash into the program's jail
    printf -- 'Run brwap: %s\n%s /usr/bin/env bash\n' \
      "${__bw_opts}" "${pre_opts}"

    # shellcheck disable=SC2086
    exec bwrap ${__bw_opts} ${pre_opts} /usr/bin/env bash || return 1
  fi

  unset __bw_opts
  unset run_opts
  unset pre_opts
  unset bw_command
  return 0
}

__bw_opts=""

# Kernel does not support user namespaces yet
__ignore_opts="user"

# bww
# by: pyamsoft <developer(dot)pyamsoft(at)gmail(dot)com>
main "$@" || exit 1
exit 0
